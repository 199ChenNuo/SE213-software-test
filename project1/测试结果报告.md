# 测试结果报告

## 引言
1. 被测软件概述

2. 文档概述

3. 测试方法
    黑盒测试中的等价类划分法、边界值分析法、决策表法

## 1. 标准计算器（李珊）

## 2. 科学计算器（王梦瑶）

## 3. 程序员计算器（胡雨奇）

## 4. 日期计算器（陈诺）

### 1. 测试环境
系统：Windows 10
位大小：64位
屏幕像素：2000x3000

#### 4.1  详细的测试结果
##### 1. GUI测试
    通过拖拽、伸缩GUI界面，证明了GUI具有一定的自适应性。在测试环境下最小大小为644x1002像素，小于这个范围时计算器不能再缩小。最大大小为占满屏幕。计算器在最大、最小和其中的大小时，都能保持GUI组件正常显示。  

  通过点击最小化、最大化、关闭按钮、输入组件，证明计算器GUI的按钮、组件具有正常的功能。

##### 2. 等价类测试

  1. 日期之间的间隔时间

| 编号 | 输入1 | 输入2 | 有效等价类 | 期望输出 | 实际输出 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 1 | 2019年2月28日 | 2019年3月1日 | 包含2月尾的一般非闰年 |1天|1天|
| 2 | 2020年2月28日 | 2020年3月1日 | 包含2月尾的一般闰年 |2天|2天|
| 3 | 1900年2月28日 | 1900年3月1日 | 包含2月尾，年份为整除4且整除100的非闰年 |1天|1天|
| 4 | 2000年2月28日 | 2000年3月1日 | 包含2月尾，年份为被4整除被100整除且被400整除的世纪闰年 |2天|2天|
| 5 | 2018年1月1日 | 2019年1月1日 | 输入1和输入2跨年 |1年或365天|1年 <br> 356天|
| 6 | 2019年4月14日 | 2019年5月14日 | 输入1和输入2跨月 |1月或30天|1月<br>30天|
| 7 | 2020年4月14日 | 2019年4月14日 | 输入1小于输入2 |提示错误或显示正确间隔|1年<br>366天|
| 8 | 2019年4月14日 | 2019年4月14日 | 相同日期 |0天|相同日期|
| 9 | 2020年5月01日 | 2019年4月14日 | 普通输入 |1年0月13天或383天|1年,2周,3天<br>383天|

   可以看到，输出结果全部是正确的。虽然有一些测试用例的输出结果与期望输出有一些不同，但是具有相同的语义信息（例如第9条测试用例），因此可以认为日期之间的相隔时间功能通过理论等价类测试。

  2. 添加天数

| 编号 |     输入1      | 输入2 |                      有效等价类                      | 期望输出 | 实际输出 |
| :--: | :------------: | :---: | :--------------------------------------------------: | :-----: | :------: |
|  1   | 2019年2月28日  |   1   |             包含2月尾，年数为一般非闰年              |2019年3月1日|2019年3月1日|
|  1   | 2020年2月28日  |   1   |              包含2月尾，年数为一般闰年               |2020年2月29日|2020年2月29日|
|  2   | 1900年2月28日  |   1   |       包含2月尾，年数为整除4且整除100的非闰年        |1900年3月1日|1900年3月1日|
|  3   | 2000年2月28日  |   1   | 包含2月尾，年数为整除4且整除100且被400整除的世纪闰年 |2000年2月29日|2000年2月29日|
|  4   | 2018年12月31日 |   1   |                     添加天数跨年                     |2019年1月1日|2019年1月1日|
|  5   | 2019年4月30日  |   1   |                     添加天数跨月                     |2019年5月1日|2019年5月1日|
|  6   | 2019年4月30日  |   0   |                      未添加天数                      |提示未添加天数或2019年4月30日|2019年4月30日|


3. 减去天数

| 编号 |     输入1      | 输入2 |                      有效等价类                      |                      期望输出                      |                      实际输出                      |
| :--: | :------------: | :---: | :--------------------------------------------------: | :--------------------------------------------------: | :--------------------------------------------------: |
|  1   |  2019年3月1日  |   1   |             包含2月尾，年数为一般非闰年              |             2019年2月28日             |             2019年2月28日    |
|  2   |  2020年3月1日  |   1   |              包含2月尾，年数为一般闰年               |              2020年2月29日              |              2020年2月29日              |
|  3   |  1900年3月1日  |   1   |       包含2月尾，年数为整除4且整除100的非闰年        |       1900年2月28日       |       1900年2月28日       |
|  4   |  2000年3月1日  |   1   | 包含2月尾，年数为整除4且整除100且被400整除的世纪闰年 | 2000年2月29日 | 2000年2月29日 |
|  5   | 2019年1月1日 |   1   |                     减去天数跨年                     |                     2018年12月31日                     |                     2018年12月31日                     |
|  6   | 2019年5月1日 |   1   |                     减去天数跨月                     |                     2019年4月30日                     |                     2019年4月30日                     |
|  7   | 2019年4月30日  |   0   |                      未减去天数                      |                                            |                                            |
##### 2. 边界值测试

1. 日期之间的相隔时间

* 输入的最小值：1601年1月1日
* 输入的最大值：2550年12月31日

因为GUI输入不支持输入max+和min-，所以这里只基于单故障假设做测试，不做健壮性测试。

| 编号 | 输入1 | 输入2 | 与边界值关系 | 期望输出 | 实际输出 |
| :--: | :---: | :---: | :----------: | :----------: | :----------: |
|  1   | 2019年04月14日 | 1601年01月01日 | <1nom, 2min> | 152774天 | 418年，3月，1周，6天<br>152774天 |
|  2   |   2019年04月14日   |   1601年01月02日   | <1nom, 2min+> | 152773天 | 418年，3月，1周，5天<br>152773天 |
|  3   |   2019年04月14日   | 2019年04月14日 | <1nom, 2nom> | 0天 | 相同日期 |
|  4   |   2019年04月14日   | 2550年12月30日 | <1nom, 2max-> | 194204天 | 531年，8月，2周，2天<br>194204天 |
|  5   |   2019年04月14日   | 2550年12月31日 | <1nom, 2max> | 194205天 | 531年，8月，2周，3天<br/>194205天 |
|  6   |   1601年01月01日   | 2019年04月14日 | <1min, 2nom> | 152774天 | 418年，3月，1周，6天<br/>152774天 |
|  7   |   1601年01月02日   | 2019年04月14日 | <1min+, 2nom> | 152773天 | 418年，3月，1周，5天<br/>152773天 |
|  8   |   2550年12月30日    | 2019年04月14日 | <max-, 2nom> | 194204天 | 531年，8月，2周，2天<br/>194204天 |
|  9   |   2550年12月31日    | 2019年04月14日 | <1max, 2nom> | 194205天 | 531年，8月，2周，3天<br/>194205天 |

2. 添加天数
* 初始时间范围：[1601年1月1日, 2550年12月31日]
* 添加时间范围：[0年0月0天, 999年999月999天]

前文使用了单故障假设做测试，这里选用最坏情况测试。
（同样由于GUI限制了输入，这里没有采用健壮最坏情况测试）

| 编号 | 输入1 | 输入2 | 与边界值关系 | 期望输出 | 实际输出 |
| :--: | :---: | :---: | :----------: | :----------: | :----------: |
|  1   | 1601年01月01日 | 0年0月0天 | <1min, 2min> | 1601年01月01日 | 1601年1月1日 |
|  2   |   1601年01月01日   |   0年0月1天   | <1min, 2min+> | 1601年01月02日 | 1601年1月2日 |
|  3   |   1601年01月01日   | 1年1月1天 | <1min, 2nom> | 1602年2月2日 | 1602年2月2日 |
|  4   |   1601年01月01日   | 999年999天998天 | <1min, 2max-> | 2685年12月24日 | 2685年12月24日 |
|  5   |   1601年01月01日   | 999年999天999天 | <1min, 2max> | 2685年12月25日 | 2685年12月25日 |
|  6   |   1601年01月02日   | 0年0月0天 | <1min+, 2min> | 1601年01月02日 | 1601年01月02日 |
|  7   |   1601年01月02日   | 0年0月1天 | <1min+, 2min+> | 1601年01月03日 | 1601年01月03日 |
|  8   |   1601年01月02日    | 1年1月1天 | <1min+, 2nom> | 1602年02月03日 | 1602年02月03日 |
|  9   |   1601年01月02日    | 999年999天998天 | <1min+, 2max-> | 2685年12月25日 | 2685年12月25日 |
|  10   |   1601年01月02日    | 999年999天999天 | <1min+, 2max> | 2685年12月26日 | 2685年12月26日 |
|  11   |    2019年04月14日   | 0年0月0天 | <1nom, 2min> | 2019年4月14日 | 2019年4月14日 |
|  12   |   2019年04月14日    | 0年0月1天 | <1nom, 2min+> | 2019年4月15日 | 2019年4月15日 |
|  13   |   2019年04月14日    | 1年1月1天 | <1nom, 2nom> | 2020年5月15日 | 2020年5月15日 |
|  14   |   2019年04月14日    | 999年999天998天 | <1nom, 2max-> | 3104年4月7日 | 3104年4月7日 |
|  15   |   2019年04月14日    | 999年999天999天 | <1nom, 2max> | 3104年4月8日 | 3104年4月8日 |
|  16   |   2550年12月30日    | 0年0月0天 | <1max, 2min> | 2550年12月30日 | 2550年12月30日 |
|  17   |   2550年12月30日    | 0年0月1天 | <1max, 2min+> | 2550年12月31日 | 2550年12月31日 |
|  18   |   2550年12月30日    | 1年1月1天 | <1max, 2nom> | 2552年1月31日 | 2552年1月31日 |
|  19   |   2550年12月30日    | 999年999天998天 | <1max, 2max-> | 3635年12月23日 | 3635年12月23日 |
|  20   |   2550年12月30日    | 999年999天999天 | <1max, 2max> | 3635年12月24日 | 3635年12月24日 |
|  21   |   2550年12月31日    | 0年0月0天 | <1max, 2min> | 2550年12月31日 | 2550年12月31日 |
|  22   |   2550年12月31日    | 0年0月1天 | <1max, 2min+> | 2551年1月1日 | 2551年1月1日 |
|  23   |   2550年12月31日    | 1年1月1天 | <1max, 2nom> | 2552年2月1日 | 2552年2月1日 |
|  24   |   2550年12月31日    | 999年999天998天 | <1max, 2max-> | 3635年12月24日 | 3635年12月24日 |
|  25   |   2550年12月31日    | 999年999天999天 | <1max, 2max> | 3635年12月25日 | 3635年12月25日 |


3. 减去天数  
初始时间范围：[1601年1月1日, 2550年12月31日]
减去时间范围：[0年0月0天, 999年999月999天]
这里同样选用最坏情况测试。

| 编号 | 输入1 | 输入2 | 与边界值关系 | 期望输出 | 实际输出 |
| :--: | :---: | :---: | :----------: | :----------: | :----------: |
|  1   | 1601年01月01日 | 0年0月0天 | <1min, 2min> | 1601年01月01日 | 1601年01月01日 |
|  2   |   1601年01月01日   |   0年0月1天   | <1min, 2min+> | 提示用户超过下限 | 超出日期 |
|  3   |   1601年01月01日   | 1年1月1天 | <1min, 2nom> | 提示用户超过下限 | 超出日期 |
|  4   |   1601年01月01日   | 999年999天998天 | <1min, 2max-> | 提示用户超过下限 | 超出日期 |
|  5   |   1601年01月01日   | 999年999天999天 | <1min, 2max> | 提示用户超过下限 | 超出日期 |
|  6   |   1601年01月02日   | 0年0月0天 | <1min+, 2min> | 1601年01月02日 | 1601年01月02日 |
|  7   |   1601年01月02日   | 0年0月1天 | <1min+, 2min+> | 1601年01月01日 | 1601年01月01日 |
|  8   |   1601年01月02日    | 1年1月1天 | <1min+, 2nom> | 提示用户超过下限 | 超出日期 |
|  9   |   1601年01月02日    | 999年999天998天 | <1min+, 2max-> | 提示用户超过下限 | 超出日期 |
|  10   |   1601年01月02日    | 999年999天999天 | <1min+, 2max> | 提示用户超过下限 | 超出日期 |
|  11   |    2019年04月14日   | 0年0月0天 | <1nom, 2min> | 2019年4月14日 | 2019年4月14日 |
|  12   |   2019年04月14日    | 0年0月1天 | <1nom, 2min+> | 2019年4月13日 | 2019年4月13日 |
|  13   |   2019年04月14日    | 1年1月1天 | <1nom, 2nom> | 2018年3月13日 | 2018年3月13日 |
|  14   |   2019年04月14日    | 999年999天998天 | <1nom, 2max-> | 提示用户超过下限 | 超出日期 |
|  15   |   2019年04月14日    | 999年999天999天 | <1nom, 2max> | 提示用户超过下限 | 超出日期 |
|  16   |   2550年12月30日    | 0年0月0天 | <1max, 2min> | 2550年12月30日 | 2550年12月30日 |
|  17   |   2550年12月30日    | 0年0月1天 | <1max, 2min+> | 2550年12月29日 | 2550年12月29日 |
|  18   |   2550年12月30日    | 1年1月1天 | <1max, 2nom> | 2549年11月29日 | 2549年11月29日 |
|  19   |   2550年12月30日    | 999年999天998天 | <1max, 2max-> | 提示用户超过下限 | 超出日期 |
|  20   |   2550年12月30日    | 999年999天999天 | <1max, 2max> | 提示用户超过下限 | 超出日期 |
|  21   |   2550年12月31日    | 0年0月0天 | <1max, 2min> | 2550年12月31日 | 2550年12月31日 |
|  22   |   2550年12月31日    | 0年0月1天 | <1max, 2min+> | 2550年12月30日 | 2550年12月30日 |
|  23   |   2550年12月31日    | 1年1月1天 | <1max, 2nom> | 2549年11月30日 | 2549年11月30日 |
|  24   |   2550年12月31日    | 999年999天998天 | <1max, 2max-> | 提示用户超过下限 | 超出日期 |
|  25   |   2550年12月31日    | 999年999天999天 | <1max, 2max> | 提示用户超过下限 | 超出日期 |

测试结果显示出了一个比较怪异的现象：计算机支持出现大于输入上界的结果，但是不支持出现小于输入下界的结果。也即：可以出现在2550年12月31日后的结果，但是本应出现先与1601年1月1日的结果时会显示超出日期。

## 参考
1. [软件测试实验报告](https://wenku.baidu.com/view/5887260ce45c3b3566ec8b2a.html)
2. [实验报告2](https://max.book118.com/html/2018/0908/5040032112001313.shtm)
